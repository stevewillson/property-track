<script src="https://npmcdn.com/pdfjs-dist/build/pdf.js"></script>

<script type="module" >
    import { PropertyItem } from './propertyitem.js';

    function separateByMPO(textArray) {
        
        var mpoArray = [];
        mpoArray[0] = [];
        
        var mpoIndex = 0;
        var firstMPO = true;
            
        textArray.forEach( function(textElement) {
            // if text == MPO then start the MPO object
            // end the object once the next MPO is reached, or the end of the document

            if (textElement == "MPO") {
                if (firstMPO != true) {
                    mpoIndex = mpoIndex + 1;
                }
                firstMPO = false;
                mpoArray[mpoIndex] = [];
            }
            if (firstMPO != true) {
                mpoArray[mpoIndex].push(textElement);
            }
        })
        return mpoArray;
    }

    function separateByNSN(mpoElement) {

        var nsnArray = [];
        var nsnIndex = 0;
        var firstNSN = true;

        // NSN + 6 = NSN number
        // NSN Description + 6 = Nomenclature
        // UI + 6 = UI
        // OH Qty + 6 = oh_qty
        // first SysNo + 6 = first_sn
        // if there is no SN, then the next element will be NSN or MPO
        // if the UI is KT, then there is a 'SysNo' field
        var sn_position = false;
        var containsSysNo = false;

        var lin = mpoElement[3].split(" ")[0];
        
        for  ( let index = 0; index < mpoElement.length; index++ ) {

            if (mpoElement[index] == "NSN") {
                if (firstNSN != true) {
                    nsnIndex = nsnIndex + 1;
                    // if the current index points to 'NSN' not in a SN block
                    sn_position = false;
                }
                firstNSN = false;
                let ui = mpoElement[index + 8];
                nsnArray[nsnIndex] = {
                    "lin": lin,
                    "nsn": mpoElement[index + 6],
                    "nomenclature": mpoElement[index + 7],
                    "ui": ui,
                    "oh_qty": mpoElement[index + 11],
                }
                if (ui == "KT") {
                    containsSysNo = true;
                }
            }

            // look for a SN block
            // SN blocks have 'SysNo SerNo/RegNo/LotNo SysNo SerNo/RegNo/LotNo SysNo SerNo/RegNo/LotNo'
            if (mpoElement[index] == "SysNo") {
                index = index + 6
                sn_position = true;
                nsnArray[nsnIndex].sn = [];
            }

            if (sn_position == true) {
                // if the SNs are spread over two pages
                if (mpoElement[index] == "Sub Hand Receipt") {
                    index = index + 20;
                    // if on a page boundary and no more SNs, 
                    // then continue to see if there is another NSN in the MPO
                    if (index > mpoElement.length) {
                        continue;
                    }
                }
                if (mpoElement[index] == "From") {
                    sn_position = false;
                    // this is the last item, it is no longer a sn block, but continue to check if there are 
                    // more 'NSN' entries in the rest of the MPO entry
                    continue; 
                }
                // the SN block contains the 'SysNo' field also, add one to the index to
                // only get the SN, don't include the SysNo
                if (containsSysNo == true) {
                    index = index + 1;
                }
                // in a sn block, add the entry to the sn array 
                // expect a SN to not have any spaces
                nsnArray[nsnIndex]["sn"].push(mpoElement[index]);
            }
        }
        return nsnArray
    }

    function addCyclicDates(jsonIn) {        
            // reverse order of the cyclic numbers to inventory per month
            var cyclicNumbers = [
                "S60290", 
                "S05003", 
                "N00000", 
                "G00000", 
                "B67840", 
                "70224N", 
                "70223N", 
                "70210N", 
                "70209N",
                "000000",
            ]

            var months = [
                "Oct",
                "Sep",
                "Aug",
                "Jul",
                "Jun",
                "May",
                "Apr",
                "Mar",
                "Feb",
                "Jan",   
            ]

            // iterate through the items in the jsonIn array
            for (let index = 0; index < jsonIn.items.length; index++) {
                for (let j = 0; j < cyclicNumbers.length; j++) {
                    if (jsonIn.items[index].lin >= cyclicNumbers[j]) {
                        jsonIn.items[index].monthly_cyclic = months[j];
                        break;
                    }
                }
            }
        return jsonIn;
    }

    function jsonToCsv(jsonIn) {

        // convert the json object to a CSV format, use '|' as the separator
        const items = jsonIn.items
        const replacer = (key, value) => value === null ? '' : value // specify how you want to handle null values here
        const header = Object.keys(items[0])
        let csv = items.map(row => header.map(fieldName => JSON.stringify(row[fieldName], replacer)).join('|'))
        csv.unshift(header.join('|'))
        csv = csv.join('\r\n')
        return csv;
    }

    function download(filename, text) {
        var element = document.createElement('a');
        element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
        element.setAttribute('download', filename);

        element.style.display = 'none';
        document.body.appendChild(element);

        element.click();

        document.body.removeChild(element);
    }

    // The workerSrc property shall be specified.
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://npmcdn.com/pdfjs-dist/build/pdf.worker.js';

    var input = document.getElementById("file-input");
    input.onchange = function parsePropertyPdf(propertyPdfEvent) { 

        // get the file reference
        var file = propertyPdfEvent.target.files[0]; 

        // set up the reader
        var reader = new FileReader();

        // once the file is read, then get the PDF contents 
        reader.onload = readerEvent => {

            var typedarray = new Uint8Array(readerEvent.target.result); // this is the content!
            
            var loadingTask = pdfjsLib.getDocument(typedarray);
            loadingTask.promise.then(function(pdf) {
                // use *pdf* here
                var maxPages = pdf._pdfInfo.numPages;
                var pageTextPromises = []; // collecting all page promises
                for (var j = 1; j <= maxPages; j++) {
                    var page = pdf.getPage(j);
                    pageTextPromises.push(page.then(function(page) { // add page promise
                        var textContent = page.getTextContent();
                        return textContent.then(function(page){ // return content promise
                            return page // value for page text
                        });
                    }));
                }
                // Wait for all pages and sum counts
                return Promise.all(pageTextPromises).then(function (pageText) {
                    var allPageTextItems = [];
                    pageText.forEach(function aggregatePages(pageTextCont) {
                        pageTextCont.items.forEach(function aggregatePageText(pageTextItems) {
                            allPageTextItems.push(pageTextItems);
                        });
                    });


                    // remove double quotes and whitespace before and after text
                    var pageTextTrim = allPageTextItems.map(function(propItem) {
                        return propItem.str.replace(/"/g,'').trim();
                    });

                    // remove blank lines from page text
                    var pageTextNoBlanks = pageTextTrim.filter(function(propItem) {
                        return propItem != "";
                    });

                    // extract the UIC from the text

                    var uicIndex = pageTextNoBlanks.indexOf("UIC:");
                    var currentUic = pageTextNoBlanks[uicIndex + 1].split(" ").slice(-1)[0];
                    
                    // separate property items by MPO
                    var mpoArray = separateByMPO(pageTextNoBlanks);

                    var nsnArray = [];

                    // take an MPO array, then split the MPO array by NSN
                    mpoArray.forEach(function(mpoElement) {
                        nsnArray.push(...separateByNSN(mpoElement));
                    });

                    // separate each nsn element
                    var propertyItemJson = {
                        "count": 0,
                        "items": []
                    };

                    nsnArray.forEach(function createPropertyItems(nsnItem) {
                        propertyItemJson.items.push(new PropertyItem(
                            currentUic,
                            nsnItem.lin,
                            nsnItem.nsn,
                            nsnItem.nomenclature,
                            nsnItem.ui,
                            nsnItem.oh_qty,
                            nsnItem.sn || "",
                            "",
                            "",
                            "",
                        ))
                        propertyItemJson.count = propertyItemJson.count + 1;
                    })

                    // separate items with SNs to multiple lines,
                    // 1 line for each SN
                    var singlePropItems = {};
                    singlePropItems.count = 0;
                    singlePropItems.items = [];
                    var singleSnOut = {};
                    propertyItemJson.items.forEach(function dispBySingleSn(propItem){
                        singleSnOut = propItem.displaySingleSnItems()
                        singlePropItems.count = singlePropItems.count + singleSnOut.count
                        singlePropItems.items = singlePropItems.items.concat(singleSnOut.items); 
                    })

                    // iterate through the items of the singlePropItems jsonObject
                    // add 'monthly_cyclic' information

                    var singlePropItemsCyclic = addCyclicDates(singlePropItems);

                    // output as a CSV file
                    var csvOutput = jsonToCsv(singlePropItemsCyclic);

                    // output the propertyItemArray as a csv file
                    download("propertyCSV.csv", csvOutput);
                });
            });
        }
        reader.readAsArrayBuffer(file);
    };
</script>

<html>
<head>Property PDF to CSV Parser</head>
<form>
    <input id="file-input" type="file" />
</form>
</html>